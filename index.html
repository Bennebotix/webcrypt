<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Webcrypt</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.32.2/index.umd.min.js"></script>
    <script src="./worker/webcrypt.js"></script>
    <style>
      body {
        background-color: #121212;
        color: #e0e0e0;
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        width: 100dvw;
        height: 100dvh;
      }

      header {
        background: #1f1f1f;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      h1 {
        font-size: 1.25rem;
      }

      .container {
        padding: 1rem;
      }

      #password {
        width: calc(100dvw - 3rem);
        background: #1e1e1e;
        color: #0f0;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 0.5rem;
        font-family: monospace;
        font-size: 15px;
        word-break: break-word;
      }

      #pass {
        display: none;
      }

      #console {
        background: #111;
        border: 1px solid #333;
        padding: 1rem;
        margin-top: 1rem;
        height: 200px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 0.9rem;
      }

      a {
        color: #0f0;
      }

      .file-input-wrapper {
        display: inline-block;
        position: relative;
      }

      .file-input-wrapper input[type="file"] {
        display: none;
      }

      .file-input-wrapper label {
        display: inline-block;
        padding: 0.5rem 1rem;
        background-color: #1f1f1f;
        border: 1px solid #444;
        border-radius: 5px;
        color: #fff;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.2s;
      }

      .file-input-wrapper label:hover {
        background-color: #333;
      }

      #copy-btn {
        background-color: #2a2a2a;
        border: 1px solid #444;
        color: #0f0;
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
        margin-left: 0.5rem;
        border-radius: 4px;
        cursor: pointer;
        font-family: inherit;
      }

      #copy-btn:hover {
        background-color: #333;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Webcrypt</h1>
    </header>

    <div class="container">
      <div class="file-input-wrapper">
        <input type="file" id="file" />
        <label for="file">Select ZIP File</label>
      </div>

      <div id="pass">
        <h3>Password:</h3>
        <div id="password">
          <br />
          <br />
        </div>
      </div>

      <div id="console" style="display: none"></div>
    </div>

    <script>
      const consoleBox = document.querySelector("#console")
      
      const log = (msg) => {;
        consoleBox.style.display = "block";
        consoleBox.innerHTML += msg + "\n";
        consoleBox.scrollTop = consoleBox.scrollHeight;
      };

      async function publishToGitHub(zip) {
        const resolve = path => path.replace(/^\/+|\/+$/g, '');
      
        const { fs, files } = (() => {
          const files = {};
          const resolve = path => path.replace(/^\/+|\/+$/g, '');
      
          const promises = {
            async readFile(path, options = {}) {
              const p = resolve(path);
              if (!(p in files)) throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
              const data = files[p];
              if (options.encoding === 'utf8' || options === 'utf8') {
                return new TextDecoder().decode(data);
              }
              return data;
            },
      
            async writeFile(path, data) {
              files[resolve(path)] = typeof data === 'string' ? new TextEncoder().encode(data) : data;
            },
      
            async mkdir(path) {}, // no-op
            async readdir(path) {
              const prefix = resolve(path) + '/';
              const seen = new Set();
              for (const key in files) {
                if (key.startsWith(prefix)) {
                  const next = key.slice(prefix.length).split('/')[0];
                  seen.add(next);
                }
              }
              return [...seen];
            },
            async stat(path) {
              const p = resolve(path);
              if (p in files) return { isFile: () => true, isDirectory: () => false };
              const isDir = Object.keys(files).some(k => k.startsWith(p + '/'));
              if (isDir) return { isFile: () => false, isDirectory: () => true };
              throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
            },
            async lstat(path) {
              return promises.stat(path);
            },
            async unlink(path) {
              const p = resolve(path);
              if (p in files) delete files[p];
              else throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
            },
            async readlink(path) {
              throw Object.assign(new Error(`EINVAL: not a symlink`), { code: 'EINVAL' });
            },
            async symlink() {
              throw Object.assign(new Error(`EPERM: symlink not supported`), { code: 'EPERM' });
            },
            async rmdir(path) {
              const p = resolve(path);
              const hasChildren = Object.keys(files).some(k => k.startsWith(p + '/'));
              if (hasChildren) throw Object.assign(new Error(`ENOTEMPTY: ${path}`), { code: 'ENOTEMPTY' });
            },
          };
      
          const fs = { promises };
          for (const cmd in promises) {
            fs[cmd] = promises[cmd].bind(promises);
          }
      
          return { fs, files };
        })();

        let dir = "repo";
              
        try {
          await fs.promises.mkdir(dir);
        } catch {}
      
        // Extract all files/folders from JSZip into fs
        for (const [path, entry] of Object.entries(zip.files)) {
          if (entry.dir) {
            // create directories as needed
            try {
              await fs.promises.mkdir(`${dir}/${path}`);
            } catch {}
          } else {
            const content = await entry.async('uint8array');
            // write file content
            await fs.promises.writeFile(`${dir}/${path}`, content);
          }
        }
      
        // Helper to recursively list all files inside fs starting at 'dir'
        async function listAllFiles(currentDir) {
          const files = [];
          async function recurse(subdir) {
            const entries = await fs.promises.readdir(subdir);
            for (const entry of entries) {
              const fullPath = `${subdir}/${entry}`;
              const stat = await fs.promises.stat(fullPath);
              if (stat.isDirectory()) {
                await recurse(fullPath);
              } else {
                files.push(fullPath.replace(`${dir}/`, ''));
              }
            }
          }
          await recurse(currentDir);
          return files;
        }
      
        // Init Git repo and commit
        await git.init({ fs, dir, defaultBranch: 'main' });
        const allFiles = await listAllFiles(dir);
        for (const filepath of allFiles) {
          await git.add({ fs, dir, filepath });
        }
        await git.commit({
          fs,
          dir,
          message: 'Initial commit from ZIP',
          author: { name: 'Webcrypt', email: 'bennebotix@gmail.com' }
        });
      
        // Prompt GitHub info
        const token = prompt("GitHub Personal Access Token:");
        const username = prompt("GitHub Username:");
        const repoName = prompt("Name for new GitHub repository:");
        const isPrivate = confirm("Should the repository be private?");
      
        // Create new repo using GitHub API
        const createRes = await fetch('https://api.github.com/user/repos', {
          method: 'POST',
          headers: {
            Authorization: `token ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: repoName,
            description: 'Created from ZIP in browser',
            private: isPrivate
          })
        });
      
        if (!createRes.ok) {
          const err = await createRes.json();
          throw new Error(`GitHub repo creation failed: ${err.message}`);
        }
      
        // Push to GitHub
        const remoteUrl = `https://github.com/${username}/${repoName}.git`;
      
        await git.addRemote({ fs, dir, remote: 'origin', url: remoteUrl });
      
        await git.push({
          fs,
          http: git.http,
          dir,
          remote: 'origin',
          ref: 'main',
          onAuth: () => ({ username: token, password: '' }),
          onProgress: e => console.log(`Push progress: ${e.phase}`)
        });
      
        log(`Successfully pushed to https://github.com/${username}/${repoName}`);
      }



      document.querySelector("#file").addEventListener("change", async (e) => {
        const pass = btoa(Webcrypt.genSeed());

        consoleBox.innerHTML = "";
        document.querySelector("#password").innerHTML =
          `> <span id="b64">${pass}</span><button id="copy-btn">Copy</button><br />`;
        
        document.querySelector("#pass").style.display = "inherit";

        let key = await Webcrypt.genKey(pass);
        log("Generated key from password.");

        const file = e.target.files[0];
        if (!file) return;

        let oldZip = new JSZip();
        let newZip = new JSZip();

        const fileData = await file.arrayBuffer();
        log("Loaded ZIP file: " + file.name);

        const zipContent = await oldZip.loadAsync(fileData);

        const saveToZIP = async (file, path) => {
          await newZip.file(path, file, { binary: true });
          log("Added encrypted file to the ZIP: " + path);
        };

        for (const [relativePath, entry] of Object.entries(zipContent.files)) {
          if (!entry.dir) {
            const data = await entry.async("uint8array");
            const encrypted = await Webcrypt.encrypt(data, key);
            await saveToZIP(encrypted, "data/" + relativePath);
          }
        }

        
        try {
          const workerRes = await fetch("./worker/webcrypt.js");
          if (!workerRes.ok) throw new Error("Failed to fetch /worker/webcrypt.js");

          const workerBlob = await workerRes.blob();
          newZip.file("webcrypt.js", workerBlob);
          log("Added worker webcrypt.js to the ZIP.");
        } catch (err) {
          log("Error adding worker file webcrypt.js: " + err.message);
        }

        try {
          const workerRes = await fetch("./worker/backend.js");
          if (!workerRes.ok) throw new Error("Failed to fetch /worker/backend.js");

          const workerBlob = await workerRes.blob();
          newZip.file("backend.js", workerBlob);
          log("Added worker backend.js to the ZIP.");
        } catch (err) {
          log("Error adding worker worker file backend.js: " + err.message);
        }

        try {
          const workerRes = await fetch("./worker/portal.html");
          if (!workerRes.ok) throw new Error("Failed to fetch /worker/portal.html");

          const workerBlob = await workerRes.blob();
          newZip.file("portal.html", workerBlob);
          log("Added worker portal.html to the ZIP.");
        } catch (err) {
          log("Error adding worker worker file portal.html: " + err.message);
        }
        
        try {
          const workerRes = await fetch("./worker/index.html");
          if (!workerRes.ok) throw new Error("Failed to fetch /worker/index.html");

          const workerBlob = await workerRes.blob();
          newZip.file("index.html", workerBlob);
          log("Added worker index.html to the ZIP.");
        } catch (err) {
          log("Error adding worker worker file index.html: " + err.message);
        }

        log("Generating .git");

        await publishToGitHub(newZip);
        
        // const url = await zipToGitBlobUrl(newZip);

        // log(
        //   "Encrypted git file ready for download: <a href='" +
        //     url +
        //     "' download='" +
        //     webcryptFilename(file.name) +
        //     "'>Here</a>"
        // );
        
        document.querySelector("#copy-btn").addEventListener("click", e => {
          const text = document.querySelector("#b64")?.textContent.trim();
          if (text) {
            navigator.clipboard.writeText(text).then(() => {
              e.target.textContent = "Copied!";
              setTimeout(() => (e.target.textContent = "Copy"), 1000);
            });
          }
        });
      });

      function webcryptFilename(original) {
        const lastDot = original.lastIndexOf(".");
        if (lastDot === -1) return original + "_webcrypted";
      
        const name = original.slice(0, lastDot);
        return `${name}_webcrypted.git`;
      }
    </script>
  </body>
</html>
