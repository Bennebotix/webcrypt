<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Webcrypt</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.32.2/index.umd.min.js"></script>
    <script src="./worker/webcrypt.js"></script>
    <style>
      body {
        background-color: #121212;
        color: #e0e0e0;
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        width: 100dvw;
        height: 100dvh;
      }

      header {
        background: #1f1f1f;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      h1 {
        font-size: 1.25rem;
      }

      .container {
        padding: 1rem;
      }

      #password {
        width: calc(100dvw - 3rem);
        background: #1e1e1e;
        color: #0f0;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 0.5rem;
        font-family: monospace;
        font-size: 15px;
        word-break: break-word;
      }

      #pass {
        display: none;
      }

      #console {
        background: #111;
        border: 1px solid #333;
        padding: 1rem;
        margin-top: 1rem;
        height: 200px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 0.9rem;
      }

      a {
        color: #0f0;
      }

      .file-input-wrapper {
        display: inline-block;
        position: relative;
      }

      .file-input-wrapper input[type="file"] {
        display: none;
      }

      .file-input-wrapper label {
        display: inline-block;
        padding: 0.5rem 1rem;
        background-color: #1f1f1f;
        border: 1px solid #444;
        border-radius: 5px;
        color: #fff;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.2s;
      }

      .file-input-wrapper label:hover {
        background-color: #333;
      }

      #copy-btn {
        background-color: #2a2a2a;
        border: 1px solid #444;
        color: #0f0;
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
        margin-left: 0.5rem;
        border-radius: 4px;
        cursor: pointer;
        font-family: inherit;
      }

      #copy-btn:hover {
        background-color: #333;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Webcrypt</h1>
    </header>

    <div class="container">
      <div class="file-input-wrapper">
        <input type="file" id="file" />
        <label for="file">Select ZIP File</label>
      </div>

      <div id="pass">
        <h3>Password:</h3>
        <div id="password">
          <br />
          <br />
        </div>
      </div>

      <div id="console" style="display: none"></div>
    </div>

    <script>
      const consoleBox = document.querySelector("#console")
      
      const log = (msg) => {;
        consoleBox.style.display = "block";
        consoleBox.innerHTML += msg + "\n";
        consoleBox.scrollTop = consoleBox.scrollHeight;
      };

      async function zipToGitBlobUrl(zip) {
        const files = {};
      
        const resolve = path => path.replace(/^\/+|\/+$/g, '');
      
        const fs = (() => {
          const files = {};
          const resolve = path => path.replace(/^\/+|\/+$/g, '');
        
          const promises = {
            async readFile(path) {
              const p = resolve(path);
              if (!(p in files)) throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
              return files[p];
            },
            async writeFile(path, data) {
              files[resolve(path)] = data instanceof Uint8Array ? data : new TextEncoder().encode(data);
            },
            async mkdir(path) {
              // no-op for flat fs
            },
            async readdir(path) {
              const prefix = resolve(path) + '/';
              const seen = new Set();
              for (const key in files) {
                if (key.startsWith(prefix)) {
                  const next = key.slice(prefix.length).split('/')[0];
                  seen.add(next);
                }
              }
              return [...seen];
            },
            async stat(path) {
              const p = resolve(path);
              if (p in files) return { isFile: () => true, isDirectory: () => false };
              const isDir = Object.keys(files).some(k => k.startsWith(p + '/'));
              if (isDir) return { isFile: () => false, isDirectory: () => true };
              throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
            },
            async lstat(path) {
              return promises.stat(path);
            },
            async unlink(path) {
              const p = resolve(path);
              if (p in files) delete files[p];
              else throw Object.assign(new Error(`ENOENT: ${path}`), { code: 'ENOENT' });
            },
            async rmdir(path) {
              const p = resolve(path);
              const hasChildren = Object.keys(files).some(k => k.startsWith(p + '/'));
              if (hasChildren) throw Object.assign(new Error(`ENOTEMPTY: ${path}`), { code: 'ENOTEMPTY' });
              // no real dirs so no-op
            },
            async readlink(path) {
              throw Object.assign(new Error(`EINVAL: not a symlink`), { code: 'EINVAL' });
            }
          };
        
          return {
            promises,
            readFile: promises.readFile.bind(promises),
            writeFile: promises.writeFile.bind(promises),
            mkdir: promises.mkdir.bind(promises),
            readdir: promises.readdir.bind(promises),
            stat: promises.stat.bind(promises),
            lstat: promises.lstat.bind(promises),
            unlink: promises.unlink.bind(promises),
            rmdir: promises.rmdir.bind(promises),
            readlink: promises.readlink.bind(promises),
          };
        })();
      
        const dir = 'repo';
      
        for (const [path, entry] of Object.entries(zip.files)) {
          if (!entry.dir) {
            const content = await entry.async("uint8array");
            await fs.promises.writeFile(`${dir}/${path}`, content);
          }
        }
      
        await git.init({ fs: fs, dir });
      
        const allFiles = await git.listFiles({ fs: fs, dir });
        for (const f of allFiles) {
          await git.add({ fs: fs, dir, filepath: f });
        }
      
        await git.commit({
          fs: fs,
          dir,
          message: 'Initial commit from ZIP',
          author: { name: 'Webcrypt', email: 'bennebotix@gmail.com' }
        });
      
        const gitZip = new JSZip();
        for (const [path, data] of Object.entries(files)) {
          if (path.startsWith(`${dir}/.git/`)) {
            gitZip.file(path.slice(`${dir}/`.length), data);
          }
        }
      
        const gitZipBlob = await gitZip.generateAsync({ type: 'blob' });
        return URL.createObjectURL(gitZipBlob);
      }


      document.querySelector("#file").addEventListener("change", async (e) => {
        const pass = btoa(Webcrypt.genSeed());

        consoleBox.innerHTML = "";
        document.querySelector("#password").innerHTML =
          `> <span id="b64">${pass}</span><button id="copy-btn">Copy</button><br />`;
        
        document.querySelector("#pass").style.display = "inherit";

        let key = await Webcrypt.genKey(pass);
        log("Generated key from password.");

        const file = e.target.files[0];
        if (!file) return;

        let oldZip = new JSZip();
        let newZip = new JSZip();

        const fileData = await file.arrayBuffer();
        log("Loaded ZIP file: " + file.name);

        const zipContent = await oldZip.loadAsync(fileData);

        const saveToZIP = async (file, path) => {
          await newZip.file(path, file, { binary: true });
          log("Added encrypted file to the ZIP: " + path);
        };

        for (const [relativePath, entry] of Object.entries(zipContent.files)) {
          if (!entry.dir) {
            const data = await entry.async("uint8array");
            const encrypted = await Webcrypt.encrypt(data, key);
            await saveToZIP(encrypted, "data/" + relativePath);
          }
        }

        
        try {
            const workerRes = await fetch("./worker/webcrypt.js");
            if (!workerRes.ok) throw new Error("Failed to fetch /worker/webcrypt.js");

            const workerBlob = await workerRes.blob();
            newZip.file("webcrypt.js", workerBlob);
            log("Added worker webcrypt.js to the ZIP.");
        } catch (err) {
            log("Error adding worker file webcrypt.js: " + err.message);
        }

        try {
            const workerRes = await fetch("./worker/backend.js");
            if (!workerRes.ok) throw new Error("Failed to fetch /worker/backend.js");

            const workerBlob = await workerRes.blob();
            newZip.file("backend.js", workerBlob);
            log("Added worker backend.js to the ZIP.");
        } catch (err) {
            log("Error adding worker worker file backend.js: " + err.message);
        }

        try {
            const workerRes = await fetch("./worker/portal.html");
            if (!workerRes.ok) throw new Error("Failed to fetch /worker/portal.html");

            const workerBlob = await workerRes.blob();
            newZip.file("portal.html", workerBlob);
            log("Added worker portal.html to the ZIP.");
        } catch (err) {
            log("Error adding worker worker file portal.html: " + err.message);
        }
        
        try {
            const workerRes = await fetch("./worker/index.html");
            if (!workerRes.ok) throw new Error("Failed to fetch /worker/index.html");

            const workerBlob = await workerRes.blob();
            newZip.file("index.html", workerBlob);
            log("Added worker index.html to the ZIP.");
        } catch (err) {
            log("Error adding worker worker file index.html: " + err.message);
        }

        log("Generating .git");
        
        const url = await zipToGitBlobUrl(newZip);

        log(
          "Encrypted git file ready for download: <a href='" +
            url +
            "' download='" +
            webcryptFilename(file.name) +
            "'>Here</a>"
        );
        
        document.querySelector("#copy-btn").addEventListener("click", e => {
          const text = document.querySelector("#b64")?.textContent.trim();
          if (text) {
            navigator.clipboard.writeText(text).then(() => {
              e.target.textContent = "Copied!";
              setTimeout(() => (e.target.textContent = "Copy"), 1000);
            });
          }
        });
      });

      function webcryptFilename(original) {
        const lastDot = original.lastIndexOf(".");
        if (lastDot === -1) return original + "_webcrypted";
      
        const name = original.slice(0, lastDot);
        const ext = original.slice(lastDot);
        return `${name}_webcrypted${ext}`;
      }
    </script>
  </body>
</html>
